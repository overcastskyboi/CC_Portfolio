/**
 * @fileoverview Validate JSX maximum depth
 * @author Chris<wfsr@foxmail.com>
 */

'use strict';

<<<<<<< HEAD
<<<<<<< HEAD
const has = require('has');
const variableUtil = require('../util/variable');
const jsxUtil = require('../util/jsx');
const docsUrl = require('../util/docsUrl');
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const has = require('hasown');
const includes = require('array-includes');
const variableUtil = require('../util/variable');
const jsxUtil = require('../util/jsx');
const docsUrl = require('../util/docsUrl');
const reportC = require('../util/report');
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
<<<<<<< HEAD
<<<<<<< HEAD
module.exports = {
  meta: {
    docs: {
      description: 'Validate JSX maximum depth',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-max-depth')
    },
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

const messages = {
  wrongDepth: 'Expected the depth of nested jsx elements to be <= {{needed}}, but found {{found}}.',
};

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce JSX maximum depth',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-max-depth'),
    },

    messages,

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    schema: [
      {
        type: 'object',
        properties: {
          max: {
            type: 'integer',
<<<<<<< HEAD
<<<<<<< HEAD
            minimum: 0
          }
        },
        additionalProperties: false
      }
    ]
  },
  create(context) {
    const MESSAGE = 'Expected the depth of nested jsx elements to be <= {{needed}}, but found {{found}}.';
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
            minimum: 0,
          },
        },
        additionalProperties: false,
      },
    ],
  },
  create(context) {
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    const DEFAULT_DEPTH = 2;

    const option = context.options[0] || {};
    const maxDepth = has(option, 'max') ? option.max : DEFAULT_DEPTH;

    function isExpression(node) {
      return node.type === 'JSXExpressionContainer';
    }

    function hasJSX(node) {
      return jsxUtil.isJSX(node) || (isExpression(node) && jsxUtil.isJSX(node.expression));
    }

    function isLeaf(node) {
      const children = node.children;

      return !children || children.length === 0 || !children.some(hasJSX);
    }

    function getDepth(node) {
      let count = 0;

      while (jsxUtil.isJSX(node.parent) || isExpression(node.parent)) {
        node = node.parent;
        if (jsxUtil.isJSX(node)) {
<<<<<<< HEAD
<<<<<<< HEAD
          count++;
=======
          count += 1;
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
          count += 1;
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        }
      }

      return count;
    }

    function report(node, depth) {
<<<<<<< HEAD
<<<<<<< HEAD
      context.report({
        node,
        message: MESSAGE,
        data: {
          found: depth,
          needed: maxDepth
        }
      });
    }

    function findJSXElementOrFragment(variables, name) {
      function find(refs) {
        let i = refs.length;

        while (--i >= 0) {
          if (has(refs[i], 'writeExpr')) {
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      reportC(context, messages.wrongDepth, 'wrongDepth', {
        node,
        data: {
          found: depth,
          needed: maxDepth,
        },
      });
    }

    function findJSXElementOrFragment(startNode, name, previousReferences) {
      function find(refs, prevRefs) {
        for (let i = refs.length - 1; i >= 0; i--) {
          if (typeof refs[i].writeExpr !== 'undefined') {
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
            const writeExpr = refs[i].writeExpr;

            return (jsxUtil.isJSX(writeExpr)
              && writeExpr)
              || ((writeExpr && writeExpr.type === 'Identifier')
<<<<<<< HEAD
<<<<<<< HEAD
              && findJSXElementOrFragment(variables, writeExpr.name));
=======
              && findJSXElementOrFragment(startNode, writeExpr.name, prevRefs));
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
              && findJSXElementOrFragment(startNode, writeExpr.name, prevRefs));
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          }
        }

        return null;
      }

<<<<<<< HEAD
<<<<<<< HEAD
      const variable = variableUtil.getVariable(variables, name);
      return variable && variable.references && find(variable.references);
    }

    function checkDescendant(baseDepth, children) {
      baseDepth++;
      (children || []).forEach((node) => {
        if (!hasJSX(node)) {
          return;
        }

=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      const variable = variableUtil.getVariableFromContext(context, startNode, name);
      if (variable && variable.references) {
        const containDuplicates = previousReferences.some((ref) => includes(variable.references, ref));

        // Prevent getting stuck in circular references
        if (containDuplicates) {
          return false;
        }

        return find(variable.references, previousReferences.concat(variable.references));
      }

      return false;
    }

    function checkDescendant(baseDepth, children) {
      baseDepth += 1;
      (children || []).filter((node) => hasJSX(node)).forEach((node) => {
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        if (baseDepth > maxDepth) {
          report(node, baseDepth);
        } else if (!isLeaf(node)) {
          checkDescendant(baseDepth, node.children);
        }
      });
    }

    function handleJSX(node) {
      if (!isLeaf(node)) {
        return;
      }

      const depth = getDepth(node);
      if (depth > maxDepth) {
        report(node, depth);
      }
    }

    return {
      JSXElement: handleJSX,
      JSXFragment: handleJSX,

      JSXExpressionContainer(node) {
        if (node.expression.type !== 'Identifier') {
          return;
        }

<<<<<<< HEAD
<<<<<<< HEAD
        const variables = variableUtil.variablesInScope(context);
        const element = findJSXElementOrFragment(variables, node.expression.name);
=======
        const element = findJSXElementOrFragment(node, node.expression.name, []);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
        const element = findJSXElementOrFragment(node, node.expression.name, []);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

        if (element) {
          const baseDepth = getDepth(node);
          checkDescendant(baseDepth, element.children);
        }
<<<<<<< HEAD
<<<<<<< HEAD
      }
    };
  }
=======
      },
    };
  },
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      },
    };
  },
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
