/**
 * @fileoverview Prevent adjacent inline elements not separated by whitespace.
 * @author Sean Hayes
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
<<<<<<< HEAD
=======
const isCreateElement = require('../util/isCreateElement');
const report = require('../util/report');
const astUtil = require('../util/ast');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
const isCreateElement = require('../util/isCreateElement');
const report = require('../util/report');
const astUtil = require('../util/ast');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Helpers
// ------------------------------------------------------------------------------

// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
const inlineNames = [
  'a',
  'b',
  'big',
  'i',
  'small',
  'tt',
  'abbr',
  'acronym',
  'cite',
  'code',
  'dfn',
  'em',
  'kbd',
  'strong',
  'samp',
  'time',
  'var',
  'bdo',
  'br',
  'img',
  'map',
  'object',
  'q',
  'script',
  'span',
  'sub',
  'sup',
  'button',
  'input',
  'label',
  'select',
<<<<<<< HEAD
<<<<<<< HEAD
  'textarea'
=======
  'textarea',
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
  'textarea',
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
];
// Note: raw &nbsp; will be transformed into \u00a0.
const whitespaceRegex = /(?:^\s|\s$)/;

function isInline(node) {
  if (node.type === 'Literal') {
    // Regular whitespace will be removed.
    const value = node.value;
    // To properly separate inline elements, each end of the literal will need
    // whitespace.
    return !whitespaceRegex.test(value);
  }
  if (node.type === 'JSXElement' && inlineNames.indexOf(node.openingElement.name.name) > -1) {
    return true;
  }
<<<<<<< HEAD
<<<<<<< HEAD
  if (node.type === 'CallExpression' && inlineNames.indexOf(node.arguments[0].value) > -1) {
=======
  if (astUtil.isCallExpression(node) && inlineNames.indexOf(node.arguments[0].value) > -1) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
  if (astUtil.isCallExpression(node) && inlineNames.indexOf(node.arguments[0].value) > -1) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    return true;
  }
  return false;
}

<<<<<<< HEAD
<<<<<<< HEAD
const ERROR = 'Child elements which render as inline HTML elements should be separated by a space or wrapped in block level elements.';

=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
module.exports = {
  ERROR,
  meta: {
    docs: {
      description: 'Prevent adjacent inline elements not separated by whitespace.',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-adjacent-inline-elements')
    },
    schema: []
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const messages = {
  inlineElement: 'Child elements which render as inline HTML elements should be separated by a space or wrapped in block level elements.',
};

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow adjacent inline elements not separated by whitespace.',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-adjacent-inline-elements'),
    },
    schema: [],

    messages,
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
  },
  create(context) {
    function validate(node, children) {
      let currentIsInline = false;
      let previousIsInline = false;
      if (!children) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        currentIsInline = isInline(children[i]);
        if (previousIsInline && currentIsInline) {
<<<<<<< HEAD
<<<<<<< HEAD
          context.report({
            node,
            message: ERROR
=======
          report(context, messages.inlineElement, 'inlineElement', {
            node,
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
          report(context, messages.inlineElement, 'inlineElement', {
            node,
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          });
          return;
        }
        previousIsInline = currentIsInline;
      }
    }
    return {
      JSXElement(node) {
        validate(node, node.children);
      },
      CallExpression(node) {
<<<<<<< HEAD
<<<<<<< HEAD
        if (!node.callee || node.callee.type !== 'MemberExpression' || node.callee.property.name !== 'createElement') {
=======
        if (!isCreateElement(context, node)) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
        if (!isCreateElement(context, node)) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          return;
        }
        if (node.arguments.length < 2 || !node.arguments[2]) {
          return;
        }
<<<<<<< HEAD
<<<<<<< HEAD
        const children = node.arguments[2].elements;
        validate(node, children);
      }
    };
  }
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        const children = 'elements' in node.arguments[2] ? node.arguments[2].elements : undefined;
        validate(node, children);
      },
    };
  },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
