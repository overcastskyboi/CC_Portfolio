/**
 * @fileoverview Prevents usage of Function.prototype.bind and arrow functions
 *               in React component props.
 * @author Daniel Lo Nigro <dan.cx>
 * @author Jacky Ho
 */

'use strict';

const propName = require('jsx-ast-utils/propName');
<<<<<<< HEAD
<<<<<<< HEAD
const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
const jsxUtil = require('../util/jsx');
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const docsUrl = require('../util/docsUrl');
const astUtil = require('../util/ast');
const jsxUtil = require('../util/jsx');
const report = require('../util/report');
const getAncestors = require('../util/eslint').getAncestors;
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// -----------------------------------------------------------------------------
// Rule Definition
// -----------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
const violationMessageStore = {
  bindCall: 'JSX props should not use .bind()',
  arrowFunc: 'JSX props should not use arrow functions',
  bindExpression: 'JSX props should not use ::',
  func: 'JSX props should not use functions'
};

module.exports = {
  meta: {
    docs: {
      description: 'Prevents usage of Function.prototype.bind and arrow functions in React component props',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('jsx-no-bind')
    },

=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const messages = {
  bindCall: 'JSX props should not use .bind()',
  arrowFunc: 'JSX props should not use arrow functions',
  bindExpression: 'JSX props should not use ::',
  func: 'JSX props should not use functions',
};

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow `.bind()` or arrow functions in JSX props',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('jsx-no-bind'),
    },

    messages,

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    schema: [{
      type: 'object',
      properties: {
        allowArrowFunctions: {
          default: false,
<<<<<<< HEAD
<<<<<<< HEAD
          type: 'boolean'
        },
        allowBind: {
          default: false,
          type: 'boolean'
        },
        allowFunctions: {
          default: false,
          type: 'boolean'
        },
        ignoreRefs: {
          default: false,
          type: 'boolean'
        },
        ignoreDOMComponents: {
          default: false,
          type: 'boolean'
        }
      },
      additionalProperties: false
    }]
  },

  create: Components.detect((context) => {
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          type: 'boolean',
        },
        allowBind: {
          default: false,
          type: 'boolean',
        },
        allowFunctions: {
          default: false,
          type: 'boolean',
        },
        ignoreRefs: {
          default: false,
          type: 'boolean',
        },
        ignoreDOMComponents: {
          default: false,
          type: 'boolean',
        },
      },
      additionalProperties: false,
    }],
  },

  create(context) {
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    const configuration = context.options[0] || {};

    // Keep track of all the variable names pointing to a bind call,
    // bind expression or an arrow function in different block statements
    const blockVariableNameSets = {};

<<<<<<< HEAD
<<<<<<< HEAD
=======
    /**
     * @param {string | number} blockStart
     */
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
    /**
     * @param {string | number} blockStart
     */
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    function setBlockVariableNameSet(blockStart) {
      blockVariableNameSets[blockStart] = {
        arrowFunc: new Set(),
        bindCall: new Set(),
        bindExpression: new Set(),
<<<<<<< HEAD
<<<<<<< HEAD
        func: new Set()
=======
        func: new Set(),
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
        func: new Set(),
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      };
    }

    function getNodeViolationType(node) {
<<<<<<< HEAD
<<<<<<< HEAD
      const nodeType = node.type;

      if (
        !configuration.allowBind
        && nodeType === 'CallExpression'
=======
      if (
        !configuration.allowBind
        && astUtil.isCallExpression(node)
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      if (
        !configuration.allowBind
        && astUtil.isCallExpression(node)
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        && node.callee.type === 'MemberExpression'
        && node.callee.property.type === 'Identifier'
        && node.callee.property.name === 'bind'
      ) {
        return 'bindCall';
      }
<<<<<<< HEAD
<<<<<<< HEAD
      if (nodeType === 'ConditionalExpression') {
=======
      if (node.type === 'ConditionalExpression') {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      if (node.type === 'ConditionalExpression') {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        return getNodeViolationType(node.test)
               || getNodeViolationType(node.consequent)
               || getNodeViolationType(node.alternate);
      }
<<<<<<< HEAD
<<<<<<< HEAD
      if (!configuration.allowArrowFunctions && nodeType === 'ArrowFunctionExpression') {
        return 'arrowFunc';
      }
      if (!configuration.allowFunctions && nodeType === 'FunctionExpression') {
        return 'func';
      }
      if (!configuration.allowBind && nodeType === 'BindExpression') {
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      if (!configuration.allowArrowFunctions && node.type === 'ArrowFunctionExpression') {
        return 'arrowFunc';
      }
      if (
        !configuration.allowFunctions
        && (node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration')
      ) {
        return 'func';
      }
      if (!configuration.allowBind && node.type === 'BindExpression') {
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        return 'bindExpression';
      }

      return null;
    }

<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    /**
     * @param {string | number} violationType
     * @param {unknown} variableName
     * @param {string | number} blockStart
     */
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    function addVariableNameToSet(violationType, variableName, blockStart) {
      blockVariableNameSets[blockStart][violationType].add(variableName);
    }

    function getBlockStatementAncestors(node) {
<<<<<<< HEAD
<<<<<<< HEAD
      return context.getAncestors(node).reverse().filter(
        (ancestor) => ancestor.type === 'BlockStatement'
      );
=======
      return getAncestors(context, node).filter(
        (ancestor) => ancestor.type === 'BlockStatement'
      ).reverse();
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      return getAncestors(context, node).filter(
        (ancestor) => ancestor.type === 'BlockStatement'
      ).reverse();
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    }

    function reportVariableViolation(node, name, blockStart) {
      const blockSets = blockVariableNameSets[blockStart];
      const violationTypes = Object.keys(blockSets);

      return violationTypes.find((type) => {
        if (blockSets[type].has(name)) {
<<<<<<< HEAD
<<<<<<< HEAD
          context.report({node, message: violationMessageStore[type]});
=======
          report(context, messages[type], type, {
            node,
          });
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
          report(context, messages[type], type, {
            node,
          });
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          return true;
        }

        return false;
      });
    }

    function findVariableViolation(node, name) {
      getBlockStatementAncestors(node).find(
        (block) => reportVariableViolation(node, name, block.range[0])
      );
    }

    return {
      BlockStatement(node) {
        setBlockVariableNameSet(node.range[0]);
      },

<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      FunctionDeclaration(node) {
        const blockAncestors = getBlockStatementAncestors(node);
        const variableViolationType = getNodeViolationType(node);

        if (blockAncestors.length > 0 && variableViolationType) {
          addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].range[0]);
        }
      },

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      VariableDeclarator(node) {
        if (!node.init) {
          return;
        }
        const blockAncestors = getBlockStatementAncestors(node);
        const variableViolationType = getNodeViolationType(node.init);

        if (
          blockAncestors.length > 0
          && variableViolationType
<<<<<<< HEAD
<<<<<<< HEAD
          && node.parent.kind === 'const' // only support const right now
        ) {
          addVariableNameToSet(
            variableViolationType, node.id.name, blockAncestors[0].range[0]
          );
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          && 'kind' in node.parent
          && node.parent.kind === 'const' // only support const right now
        ) {
          addVariableNameToSet(variableViolationType, 'name' in node.id ? node.id.name : undefined, blockAncestors[0].range[0]);
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        }
      },

      JSXAttribute(node) {
        const isRef = configuration.ignoreRefs && propName(node) === 'ref';
        if (isRef || !node.value || !node.value.expression) {
          return;
        }
        const isDOMComponent = jsxUtil.isDOMComponent(node.parent);
        if (configuration.ignoreDOMComponents && isDOMComponent) {
          return;
        }
        const valueNode = node.value.expression;
        const valueNodeType = valueNode.type;
        const nodeViolationType = getNodeViolationType(valueNode);

        if (valueNodeType === 'Identifier') {
          findVariableViolation(node, valueNode.name);
        } else if (nodeViolationType) {
<<<<<<< HEAD
<<<<<<< HEAD
          context.report({
            node, message: violationMessageStore[nodeViolationType]
          });
        }
      }
    };
  })
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          report(context, messages[nodeViolationType], nodeViolationType, {
            node,
          });
        }
      },
    };
  },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
