/**
 * @fileoverview Disallow undeclared variables in JSX
 * @author Yannick Croissant
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
<<<<<<< HEAD
const jsxUtil = require('../util/jsx');
=======
const eslintUtil = require('../util/eslint');
const jsxUtil = require('../util/jsx');
const report = require('../util/report');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
const eslintUtil = require('../util/eslint');
const jsxUtil = require('../util/jsx');
const report = require('../util/report');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const messages = {
  undefined: '\'{{identifier}}\' is not defined.',
};

/** @type {import('eslint').Rule.RuleModule} */
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
module.exports = {
  meta: {
    docs: {
      description: 'Disallow undeclared variables in JSX',
      category: 'Possible Errors',
      recommended: true,
<<<<<<< HEAD
<<<<<<< HEAD
      url: docsUrl('jsx-no-undef')
    },
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      url: docsUrl('jsx-no-undef'),
    },

    messages,

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    schema: [{
      type: 'object',
      properties: {
        allowGlobals: {
<<<<<<< HEAD
<<<<<<< HEAD
          type: 'boolean'
        }
      },
      additionalProperties: false
    }]
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          type: 'boolean',
        },
      },
      additionalProperties: false,
    }],
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
  },

  create(context) {
    const config = context.options[0] || {};
    const allowGlobals = config.allowGlobals || false;

    /**
     * Compare an identifier with the variables declared in the scope
     * @param {ASTNode} node - Identifier or JSXIdentifier node
     * @returns {void}
     */
    function checkIdentifierInJSX(node) {
<<<<<<< HEAD
<<<<<<< HEAD
      let scope = context.getScope();
      const sourceCode = context.getSourceCode();
=======
      let scope = eslintUtil.getScope(context, node);
      const sourceCode = eslintUtil.getSourceCode(context);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      let scope = eslintUtil.getScope(context, node);
      const sourceCode = eslintUtil.getSourceCode(context);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      const sourceType = sourceCode.ast.sourceType;
      const scopeUpperBound = !allowGlobals && sourceType === 'module' ? 'module' : 'global';
      let variables = scope.variables;
      let i;
      let len;

      // Ignore 'this' keyword (also maked as JSXIdentifier when used in JSX)
      if (node.name === 'this') {
        return;
      }

      while (scope.type !== scopeUpperBound && scope.type !== 'global') {
        scope = scope.upper;
        variables = scope.variables.concat(variables);
      }
      if (scope.childScopes.length) {
        variables = scope.childScopes[0].variables.concat(variables);
        // Temporary fix for babel-eslint
        if (scope.childScopes[0].childScopes.length) {
          variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
        }
      }

      for (i = 0, len = variables.length; i < len; i++) {
        if (variables[i].name === node.name) {
          return;
        }
      }

<<<<<<< HEAD
<<<<<<< HEAD
      context.report({
        node,
        message: `'${node.name}' is not defined.`
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      report(context, messages.undefined, 'undefined', {
        node,
        data: {
          identifier: node.name,
        },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      });
    }

    return {
      JSXOpeningElement(node) {
        switch (node.name.type) {
          case 'JSXIdentifier':
            if (jsxUtil.isDOMComponent(node)) {
              return;
            }
            node = node.name;
            break;
          case 'JSXMemberExpression':
            node = node.name;
            do {
              node = node.object;
            } while (node && node.type !== 'JSXIdentifier');
            break;
          case 'JSXNamespacedName':
<<<<<<< HEAD
<<<<<<< HEAD
            node = node.name.namespace;
            break;
=======
            return;
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
            return;
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          default:
            break;
        }
        checkIdentifierInJSX(node);
<<<<<<< HEAD
<<<<<<< HEAD
      }
    };
  }
=======
      },
    };
  },
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      },
    };
  },
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
