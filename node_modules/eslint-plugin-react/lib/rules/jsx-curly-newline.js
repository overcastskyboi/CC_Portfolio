/**
 * @fileoverview enforce consistent line breaks inside jsx curly
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const eslintUtil = require('../util/eslint');
const report = require('../util/report');

const getSourceCode = eslintUtil.getSourceCode;
const getText = eslintUtil.getText;
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

function getNormalizedOption(context) {
  const rawOption = context.options[0] || 'consistent';

  if (rawOption === 'consistent') {
    return {
      multiline: 'consistent',
<<<<<<< HEAD
<<<<<<< HEAD
      singleline: 'consistent'
=======
      singleline: 'consistent',
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      singleline: 'consistent',
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    };
  }

  if (rawOption === 'never') {
    return {
      multiline: 'forbid',
<<<<<<< HEAD
<<<<<<< HEAD
      singleline: 'forbid'
=======
      singleline: 'forbid',
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      singleline: 'forbid',
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    };
  }

  return {
    multiline: rawOption.multiline || 'consistent',
<<<<<<< HEAD
<<<<<<< HEAD
    singleline: rawOption.singleline || 'consistent'
  };
}

=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    singleline: rawOption.singleline || 'consistent',
  };
}

const messages = {
  expectedBefore: 'Expected newline before \'}\'.',
  expectedAfter: 'Expected newline after \'{\'.',
  unexpectedBefore: 'Unexpected newline before \'}\'.',
  unexpectedAfter: 'Unexpected newline after \'{\'.',
};

/** @type {import('eslint').Rule.RuleModule} */
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
module.exports = {
  meta: {
    type: 'layout',

    docs: {
<<<<<<< HEAD
<<<<<<< HEAD
      description: 'Enforce consistent line breaks inside jsx curly',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-curly-newline')
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      description: 'Enforce consistent linebreaks in curly braces in JSX attributes and expressions',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-curly-newline'),
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    },

    fixable: 'whitespace',

    schema: [
      {
<<<<<<< HEAD
<<<<<<< HEAD
        oneOf: [
          {
            enum: ['consistent', 'never']
=======
        anyOf: [
          {
            enum: ['consistent', 'never'],
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
        anyOf: [
          {
            enum: ['consistent', 'never'],
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          },
          {
            type: 'object',
            properties: {
<<<<<<< HEAD
<<<<<<< HEAD
              singleline: {enum: ['consistent', 'require', 'forbid']},
              multiline: {enum: ['consistent', 'require', 'forbid']}
            },
            additionalProperties: false
          }
        ]
      }
    ],

    messages: {
      expectedBefore: 'Expected newline before \'}\'.',
      expectedAfter: 'Expected newline after \'{\'.',
      unexpectedBefore: 'Unexpected newline before \'{\'.',
      unexpectedAfter: 'Unexpected newline after \'}\'.'
    }
  },

  create(context) {
    const sourceCode = context.getSourceCode();
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
              singleline: { enum: ['consistent', 'require', 'forbid'] },
              multiline: { enum: ['consistent', 'require', 'forbid'] },
            },
            additionalProperties: false,
          },
        ],
      },
    ],

    messages,
  },

  create(context) {
    const sourceCode = getSourceCode(context);
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    const option = getNormalizedOption(context);

    // ----------------------------------------------------------------------
    // Helpers
    // ----------------------------------------------------------------------

    /**
     * Determines whether two adjacent tokens are on the same line.
     * @param {Object} left - The left token object.
     * @param {Object} right - The right token object.
     * @returns {boolean} Whether or not the tokens are on the same line.
     */
    function isTokenOnSameLine(left, right) {
      return left.loc.end.line === right.loc.start.line;
    }

    /**
     * Determines whether there should be newlines inside curlys
     * @param {ASTNode} expression The expression contained in the curlys
     * @param {boolean} hasLeftNewline `true` if the left curly has a newline in the current code.
     * @returns {boolean} `true` if there should be newlines inside the function curlys
     */
    function shouldHaveNewlines(expression, hasLeftNewline) {
      const isMultiline = expression.loc.start.line !== expression.loc.end.line;

      switch (isMultiline ? option.multiline : option.singleline) {
        case 'forbid': return false;
        case 'require': return true;
        case 'consistent':
        default: return hasLeftNewline;
      }
    }

    /**
     * Validates curlys
     * @param {Object} curlys An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
     * @param {ASTNode} expression The expression inside the curly
     * @returns {void}
     */
    function validateCurlys(curlys, expression) {
      const leftCurly = curlys.leftCurly;
      const rightCurly = curlys.rightCurly;
      const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);
      const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);
      const hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);
      const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);
      const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);

      if (hasLeftNewline && !needsNewlines) {
<<<<<<< HEAD
<<<<<<< HEAD
        context.report({
          node: leftCurly,
          messageId: 'unexpectedAfter',
          fix(fixer) {
            return sourceCode
              .getText()
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        report(context, messages.unexpectedAfter, 'unexpectedAfter', {
          node: leftCurly,
          fix(fixer) {
            return getText(context)
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
              .slice(leftCurly.range[1], tokenAfterLeftCurly.range[0])
              .trim()
              ? null // If there is a comment between the { and the first element, don't do a fix.
              : fixer.removeRange([leftCurly.range[1], tokenAfterLeftCurly.range[0]]);
<<<<<<< HEAD
<<<<<<< HEAD
          }
        });
      } else if (!hasLeftNewline && needsNewlines) {
        context.report({
          node: leftCurly,
          messageId: 'expectedAfter',
          fix: (fixer) => fixer.insertTextAfter(leftCurly, '\n')
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          },
        });
      } else if (!hasLeftNewline && needsNewlines) {
        report(context, messages.expectedAfter, 'expectedAfter', {
          node: leftCurly,
          fix: (fixer) => fixer.insertTextAfter(leftCurly, '\n'),
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        });
      }

      if (hasRightNewline && !needsNewlines) {
<<<<<<< HEAD
<<<<<<< HEAD
        context.report({
          node: rightCurly,
          messageId: 'unexpectedBefore',
          fix(fixer) {
            return sourceCode
              .getText()
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        report(context, messages.unexpectedBefore, 'unexpectedBefore', {
          node: rightCurly,
          fix(fixer) {
            return getText(context)
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
              .slice(tokenBeforeRightCurly.range[1], rightCurly.range[0])
              .trim()
              ? null // If there is a comment between the last element and the }, don't do a fix.
              : fixer.removeRange([
                tokenBeforeRightCurly.range[1],
<<<<<<< HEAD
<<<<<<< HEAD
                rightCurly.range[0]
              ]);
          }
        });
      } else if (!hasRightNewline && needsNewlines) {
        context.report({
          node: rightCurly,
          messageId: 'expectedBefore',
          fix: (fixer) => fixer.insertTextBefore(rightCurly, '\n')
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
                rightCurly.range[0],
              ]);
          },
        });
      } else if (!hasRightNewline && needsNewlines) {
        report(context, messages.expectedBefore, 'expectedBefore', {
          node: rightCurly,
          fix: (fixer) => fixer.insertTextBefore(rightCurly, '\n'),
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        });
      }
    }

    // ----------------------------------------------------------------------
    // Public
    // ----------------------------------------------------------------------

    return {
      JSXExpressionContainer(node) {
        const curlyTokens = {
          leftCurly: sourceCode.getFirstToken(node),
<<<<<<< HEAD
<<<<<<< HEAD
          rightCurly: sourceCode.getLastToken(node)
        };
        validateCurlys(curlyTokens, node.expression);
      }
    };
  }
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          rightCurly: sourceCode.getLastToken(node),
        };
        validateCurlys(curlyTokens, node.expression);
      },
    };
  },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
