/**
 * @fileoverview Enforce default props alphabetical sorting
 * @author Vladimir Kattsov
<<<<<<< HEAD
<<<<<<< HEAD
=======
 * @deprecated
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
 * @deprecated
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
 */

'use strict';

const variableUtil = require('../util/variable');
const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
<<<<<<< HEAD
const propWrapperUtil = require('../util/propWrapper');
// const propTypesSortUtil = require('../util/propTypesSort');
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const report = require('../util/report');
const log = require('../util/log');
const eslintUtil = require('../util/eslint');

const getFirstTokens = eslintUtil.getFirstTokens;
const getText = eslintUtil.getText;

let isWarnedForDeprecation = false;
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
module.exports = {
  meta: {
    docs: {
      description: 'Enforce default props alphabetical sorting',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-sort-default-props')
    },

    // fixable: 'code',

=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const messages = {
  propsNotSorted: 'Default prop types declarations should be sorted alphabetically',
};

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    deprecated: true,
    replacedBy: ['sort-default-props'],
    docs: {
      description: 'Enforce defaultProps declarations alphabetical sorting',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-sort-default-props'),
    },
    // fixable: 'code',

    messages,

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    schema: [{
      type: 'object',
      properties: {
        ignoreCase: {
<<<<<<< HEAD
<<<<<<< HEAD
          type: 'boolean'
        }
      },
      additionalProperties: false
    }]
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          type: 'boolean',
        },
      },
      additionalProperties: false,
    }],
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
  },

  create(context) {
    const configuration = context.options[0] || {};
    const ignoreCase = configuration.ignoreCase || false;

    /**
     * Get properties name
     * @param {Object} node - Property.
<<<<<<< HEAD
<<<<<<< HEAD
     * @returns {String} Property name.
=======
     * @returns {string} Property name.
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
     * @returns {string} Property name.
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
     */
    function getPropertyName(node) {
      if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
        return node.key.name;
      }
      if (node.type === 'MemberExpression') {
        return node.property.name;
      // Special case for class properties
      // (babel-eslint@5 does not expose property name so we have to rely on tokens)
      }
      if (node.type === 'ClassProperty') {
<<<<<<< HEAD
<<<<<<< HEAD
        const tokens = context.getFirstTokens(node, 2);
=======
        const tokens = getFirstTokens(context, node, 2);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
        const tokens = getFirstTokens(context, node, 2);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
      }
      return '';
    }

    /**
     * Checks if the Identifier node passed in looks like a defaultProps declaration.
     * @param   {ASTNode}  node The node to check. Must be an Identifier node.
<<<<<<< HEAD
<<<<<<< HEAD
     * @returns {Boolean}       `true` if the node is a defaultProps declaration, `false` if not
=======
     * @returns {boolean}       `true` if the node is a defaultProps declaration, `false` if not
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
     * @returns {boolean}       `true` if the node is a defaultProps declaration, `false` if not
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
     */
    function isDefaultPropsDeclaration(node) {
      const propName = getPropertyName(node);
      return (propName === 'defaultProps' || propName === 'getDefaultProps');
    }

    function getKey(node) {
<<<<<<< HEAD
<<<<<<< HEAD
      return context.getSourceCode().getText(node.key || node.argument);
=======
      return getText(context, node.key || node.argument);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      return getText(context, node.key || node.argument);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    }

    /**
     * Find a variable by name in the current scope.
<<<<<<< HEAD
<<<<<<< HEAD
     * @param  {string} name Name of the variable to look for.
     * @returns {ASTNode|null} Return null if the variable could not be found, ASTNode otherwise.
     */
    function findVariableByName(name) {
      const variable = variableUtil.variablesInScope(context).find((item) => item.name === name);
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
     * @param  {ASTNode} node The node to look for.
     * @param  {string} name Name of the variable to look for.
     * @returns {ASTNode|null} Return null if the variable could not be found, ASTNode otherwise.
     */
    function findVariableByName(node, name) {
      const variable = variableUtil
        .getVariableFromContext(context, node, name);
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

      if (!variable || !variable.defs[0] || !variable.defs[0].node) {
        return null;
      }

      if (variable.defs[0].node.type === 'TypeAlias') {
        return variable.defs[0].node.right;
      }

      return variable.defs[0].node.init;
    }

    /**
     * Checks if defaultProps declarations are sorted
     * @param {Array} declarations The array of AST nodes being checked.
     * @returns {void}
     */
    function checkSorted(declarations) {
      // function fix(fixer) {
<<<<<<< HEAD
<<<<<<< HEAD
      //   return propTypesSortUtil.fixPropTypesSort(fixer, context, declarations, ignoreCase);
=======
      //   return propTypesSortUtil.fixPropTypesSort(context, fixer, declarations, ignoreCase);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      //   return propTypesSortUtil.fixPropTypesSort(context, fixer, declarations, ignoreCase);
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      // }

      declarations.reduce((prev, curr, idx, decls) => {
        if (/Spread(?:Property|Element)$/.test(curr.type)) {
          return decls[idx + 1];
        }

        let prevPropName = getKey(prev);
        let currentPropName = getKey(curr);

        if (ignoreCase) {
          prevPropName = prevPropName.toLowerCase();
          currentPropName = currentPropName.toLowerCase();
        }

        if (currentPropName < prevPropName) {
<<<<<<< HEAD
<<<<<<< HEAD
          context.report({
            node: curr,
            message: 'Default prop types declarations should be sorted alphabetically'
=======
          report(context, messages.propsNotSorted, 'propsNotSorted', {
            node: curr,
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
          report(context, messages.propsNotSorted, 'propsNotSorted', {
            node: curr,
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
            // fix
          });

          return prev;
        }

        return curr;
      }, declarations[0]);
    }

    function checkNode(node) {
<<<<<<< HEAD
<<<<<<< HEAD
      switch (node && node.type) {
        case 'ObjectExpression':
          checkSorted(node.properties);
          break;
        case 'Identifier': {
          const propTypesObject = findVariableByName(node.name);
          if (propTypesObject && propTypesObject.properties) {
            checkSorted(propTypesObject.properties);
          }
          break;
        }
        case 'CallExpression': {
          const innerNode = node.arguments && node.arguments[0];
          if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) {
            checkNode(innerNode);
          }
          break;
        }
        default:
          break;
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      if (!node) {
        return;
      }
      if (node.type === 'ObjectExpression') {
        checkSorted(node.properties);
      } else if (node.type === 'Identifier') {
        const propTypesObject = findVariableByName(node, node.name);
        if (propTypesObject && propTypesObject.properties) {
          checkSorted(propTypesObject.properties);
        }
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      }
    }

    // --------------------------------------------------------------------------
    // Public API
    // --------------------------------------------------------------------------

    return {
<<<<<<< HEAD
<<<<<<< HEAD
      ClassProperty(node) {
=======
      'ClassProperty, PropertyDefinition'(node) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
      'ClassProperty, PropertyDefinition'(node) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        if (!isDefaultPropsDeclaration(node)) {
          return;
        }

        checkNode(node.value);
      },

      MemberExpression(node) {
        if (!isDefaultPropsDeclaration(node)) {
          return;
        }

<<<<<<< HEAD
<<<<<<< HEAD
        checkNode(node.parent.right);
      }
    };
  }
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        checkNode('right' in node.parent && node.parent.right);
      },

      Program() {
        if (isWarnedForDeprecation) {
          return;
        }

        log('The react/jsx-sort-default-props rule is deprecated. It has been renamed to `react/sort-default-props`.');
        isWarnedForDeprecation = true;
      },
    };
  },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
