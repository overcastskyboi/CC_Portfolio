/**
 * @fileoverview Ensure proper position of the first property in JSX
 * @author Joachim Seminck
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
<<<<<<< HEAD
=======
const report = require('../util/report');
const propsUtil = require('../util/props');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
const report = require('../util/report');
const propsUtil = require('../util/props');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
module.exports = {
  meta: {
    docs: {
      description: 'Ensure proper position of the first property in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-first-prop-new-line')
    },
    fixable: 'code',

    schema: [{
      enum: ['always', 'never', 'multiline', 'multiline-multiprop']
    }]
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const messages = {
  propOnNewLine: 'Property should be placed on a new line',
  propOnSameLine: 'Property should be placed on the same line as the component declaration',
};

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce proper position of the first property in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-first-prop-new-line'),
    },
    fixable: 'code',

    messages,

    schema: [{
      enum: ['always', 'never', 'multiline', 'multiline-multiprop', 'multiprop'],
    }],
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
  },

  create(context) {
    const configuration = context.options[0] || 'multiline-multiprop';

    function isMultilineJSX(jsxNode) {
      return jsxNode.loc.start.line < jsxNode.loc.end.line;
    }

    return {
      JSXOpeningElement(node) {
        if (
          (configuration === 'multiline' && isMultilineJSX(node))
          || (configuration === 'multiline-multiprop' && isMultilineJSX(node) && node.attributes.length > 1)
<<<<<<< HEAD
<<<<<<< HEAD
=======
          || (configuration === 'multiprop' && node.attributes.length > 1)
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
          || (configuration === 'multiprop' && node.attributes.length > 1)
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          || (configuration === 'always')
        ) {
          node.attributes.some((decl) => {
            if (decl.loc.start.line === node.loc.start.line) {
<<<<<<< HEAD
<<<<<<< HEAD
              context.report({
                node: decl,
                message: 'Property should be placed on a new line',
                fix(fixer) {
                  return fixer.replaceTextRange([node.name.range[1], decl.range[0]], '\n');
                }
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
              report(context, messages.propOnNewLine, 'propOnNewLine', {
                node: decl,
                fix(fixer) {
                  const nodeTypeArguments = propsUtil.getTypeArguments(node);
                  return fixer.replaceTextRange([(nodeTypeArguments || node.name).range[1], decl.range[0]], '\n');
                },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
              });
            }
            return true;
          });
<<<<<<< HEAD
<<<<<<< HEAD
        } else if (configuration === 'never' && node.attributes.length > 0) {
          const firstNode = node.attributes[0];
          if (node.loc.start.line < firstNode.loc.start.line) {
            context.report({
              node: firstNode,
              message: 'Property should be placed on the same line as the component declaration',
              fix(fixer) {
                return fixer.replaceTextRange([node.name.range[1], firstNode.range[0]], ' ');
              }
            });
          }
        }
      }
    };
  }
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        } else if (
          (configuration === 'never' && node.attributes.length > 0)
          || (configuration === 'multiprop' && isMultilineJSX(node) && node.attributes.length <= 1)
        ) {
          const firstNode = node.attributes[0];
          if (node.loc.start.line < firstNode.loc.start.line) {
            report(context, messages.propOnSameLine, 'propOnSameLine', {
              node: firstNode,
              fix(fixer) {
                return fixer.replaceTextRange([node.name.range[1], firstNode.range[0]], ' ');
              },
            });
          }
        }
      },
    };
  },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
