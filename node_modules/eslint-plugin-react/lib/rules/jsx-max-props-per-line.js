/**
 * @fileoverview Limit maximum of props on a single line in JSX
 * @author Yannick Croissant
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const getText = require('../util/eslint').getText;
const report = require('../util/report');

function getPropName(context, propNode) {
  if (propNode.type === 'JSXSpreadAttribute') {
    return getText(context, propNode.argument);
  }
  return propNode.name.name;
}
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
<<<<<<< HEAD
module.exports = {
  meta: {
    docs: {
      description: 'Limit maximum of props on a single line in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-max-props-per-line')
    },
    fixable: 'code',
    schema: [{
      type: 'object',
      properties: {
        maximum: {
          type: 'integer',
          minimum: 1
        },
        when: {
          type: 'string',
          enum: ['always', 'multiline']
        }
      }
    }]
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
const messages = {
  newLine: 'Prop `{{prop}}` must be placed on a new line',
};

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce maximum of props on a single line in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-max-props-per-line'),
    },
    fixable: 'code',

    messages,

    schema: [{
      anyOf: [{
        type: 'object',
        properties: {
          maximum: {
            type: 'object',
            properties: {
              single: {
                type: 'integer',
                minimum: 1,
              },
              multi: {
                type: 'integer',
                minimum: 1,
              },
            },
          },
        },
        additionalProperties: false,
      }, {
        type: 'object',
        properties: {
          maximum: {
            type: 'number',
            minimum: 1,
          },
          when: {
            type: 'string',
            enum: ['always', 'multiline'],
          },
        },
        additionalProperties: false,
      }],
    }],
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
  },

  create(context) {
    const configuration = context.options[0] || {};
    const maximum = configuration.maximum || 1;
<<<<<<< HEAD
<<<<<<< HEAD
    const when = configuration.when || 'always';

    function getPropName(propNode) {
      if (propNode.type === 'JSXSpreadAttribute') {
        return context.getSourceCode().getText(propNode.argument);
      }
      return propNode.name.name;
    }

    function generateFixFunction(line, max) {
      const sourceCode = context.getSourceCode();
      const output = [];
      const front = line[0].range[0];
      const back = line[line.length - 1].range[1];
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

    const maxConfig = typeof maximum === 'number'
      ? {
        single: configuration.when === 'multiline' ? Infinity : maximum,
        multi: maximum,
      }
      : {
        single: maximum.single || Infinity,
        multi: maximum.multi || Infinity,
      };

    function generateFixFunction(line, max) {
      const output = [];
      const front = line[0].range[0];
      const back = line[line.length - 1].range[1];

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      for (let i = 0; i < line.length; i += max) {
        const nodes = line.slice(i, i + max);
        output.push(nodes.reduce((prev, curr) => {
          if (prev === '') {
<<<<<<< HEAD
<<<<<<< HEAD
            return sourceCode.getText(curr);
          }
          return `${prev} ${sourceCode.getText(curr)}`;
        }, ''));
      }
      const code = output.join('\n');
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
            return getText(context, curr);
          }
          return `${prev} ${getText(context, curr)}`;
        }, ''));
      }

      const code = output.join('\n');

<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
      return function fix(fixer) {
        return fixer.replaceTextRange([front, back], code);
      };
    }

    return {
      JSXOpeningElement(node) {
        if (!node.attributes.length) {
          return;
        }

<<<<<<< HEAD
<<<<<<< HEAD
        if (when === 'multiline' && node.loc.start.line === node.loc.end.line) {
=======
        const isSingleLineTag = node.loc.start.line === node.loc.end.line;

        if ((isSingleLineTag ? maxConfig.single : maxConfig.multi) === Infinity) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
        const isSingleLineTag = node.loc.start.line === node.loc.end.line;

        if ((isSingleLineTag ? maxConfig.single : maxConfig.multi) === Infinity) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          return;
        }

        const firstProp = node.attributes[0];
        const linePartitionedProps = [[firstProp]];

        node.attributes.reduce((last, decl) => {
          if (last.loc.end.line === decl.loc.start.line) {
            linePartitionedProps[linePartitionedProps.length - 1].push(decl);
          } else {
            linePartitionedProps.push([decl]);
          }
          return decl;
        });

        linePartitionedProps.forEach((propsInLine) => {
<<<<<<< HEAD
<<<<<<< HEAD
          if (propsInLine.length > maximum) {
            const name = getPropName(propsInLine[maximum]);
            context.report({
              node: propsInLine[maximum],
              message: `Prop \`${name}\` must be placed on a new line`,
              fix: generateFixFunction(propsInLine, maximum)
            });
          }
        });
      }
    };
  }
=======
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          const maxPropsCountPerLine = isSingleLineTag && propsInLine[0].loc.start.line === node.loc.start.line
            ? maxConfig.single
            : maxConfig.multi;

          if (propsInLine.length > maxPropsCountPerLine) {
            const name = getPropName(context, propsInLine[maxPropsCountPerLine]);
            report(context, messages.newLine, 'newLine', {
              node: propsInLine[maxPropsCountPerLine],
              data: {
                prop: name,
              },
              fix: generateFixFunction(propsInLine, maxPropsCountPerLine),
            });
          }
        });
      },
    };
  },
<<<<<<< HEAD
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
=======
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
